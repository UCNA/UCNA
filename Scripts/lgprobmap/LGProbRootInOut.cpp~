#include <fstream>
#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h> 
#include <stdlib.h>
#include <math.h>
#include <cmath> 
#include "TFile.h"
#include "TH1F.h"
#include "TTreeReader.h"
#include "TTreeReaderValue.h"
#include "/home/cmswank/Documents/ucna/lgprobmap/pmtprobstuff.h"

using namespace std;
 
//This is a collection of functions that are useful for light guide map creation. 
///For an example of use look in main. 



///This function returns the probability of entering a lightguide given a position, 
	///lgnum is the light guide number, 0 is for center, 1 is for the left, 2 is for the right. 
	double lightguideprob(double xpos, double ypos,int lgnum){
	double lightprob;
	double thet1;
	double thet2;
	const double Radius=75;//*sqrt(.6); what radius??? scintilator or wire chamber.	                       
	const double pi = 3.1415926535897;  //pi
	const double p1x=Radius*sin(-pi/12);
	const double p1y=Radius*cos(pi/12);
	const double p2x=-p1x;
	const double p2y=p1y;
	const double thetaC = 40*pi/180;	//critical angle in radians 
	
	
	
		
		if  (sqrt(pow(xpos,2) + pow(ypos,2)) > Radius){
		cout<<"Impact position missed Scintillator, try again"<<"\n";
		return 0.00; 
		}

if (lgnum==2){//%on da right
	double xright;
	double yright;
	double r;
	double theta;
	r=sqrt(pow(xpos,2)+pow(ypos,2));  
	theta=-atan2(xpos,ypos);
	xright=r*sin(theta+pi/6);   //rotate lg to the right
	yright=r*cos(theta+pi/6); 
	thet1=-(atan2((p1x-xright),(p1y-xright)));
	thet2=-(atan2((p2x-xright),(p2y-yright)));
}
else if (lgnum==1){//%relative to lightguide on the left;
	
	double xleft;
	double yleft;
	double r;
	double theta;
	r=sqrt(pow(xpos,2)+pow(ypos,2));  
	theta=-atan2(xpos,ypos);
	xleft=r*sin(theta-pi/6); ///rotate lg to the left
	yleft=r*cos(theta-pi/6); 
	thet1=-(atan2((p1x-xleft),(p1y-yleft)));
	thet2=-(atan2((p2x-xleft),(p2y-yleft)));
}
	
	//Kevin's equation for phi1 and phi2 (find all accepted angles) 
else if (lgnum==0){	
	thet1=-(atan2((p1x-xpos),(p1y-ypos)));
	thet2=-(atan2((p2x-xpos),(p2y-ypos)));
}
else{ 
	cout<<"please choose a valid light guide number.\n";
	return 0;
 	 }
	//computerified heaviside in Kevin's integral: if theta gets bigger than thetaC then make it equal, mind the sign. 
		if (fabs(thet1)>thetaC){
		thet1=sign(thet1)*thetaC;
		}
		if (fabs(thet2)>thetaC){
		thet2=sign(thet2)*thetaC;
		}

	lightprob=fabs((thet1-thet2)/2/pi);///I can't remember which way it integrates, so I take abs value. 
	return lightprob;		
}	


//This gives a probability to a pmt given the offset and coupling coefficients, and pmt number.
double PMTprob(double xpos,double ypos, double offsetx,double offsety, double lga, double lgb, double lgc,int pmtnum){
	const double pi = 3.1415926535897;  //pi
	double xp, yp, r, theta, pmtprob;
	
	r=sqrt(pow(xpos-offsetx,2)+pow(ypos-offsety,2));  //r and theta in terms of scintillator center. 
	theta=-atan2(xpos-offsetx,ypos-offsety);
	
	if (pmtnum>0 && pmtnum<5){
	xp=r*sin(theta-3*pi/12-(pmtnum-1)*pi/2); ///rotate to correct orientation of LG's w.r.t. wirechamber. 
	yp=r*cos(theta-3*pi/12-(pmtnum-1)*pi/2); 
	}	
	else {cout<<"enter a valid pmt# (they are 1,2,3 or 4)\n";}

	pmtprob=lga*lightguideprob(xp,yp,1)+lgb*lightguideprob(xp,yp,0)+lgc*lightguideprob(xp,yp,2); 
	
	return pmtprob;

}






	
////the main function:
//import wirechamber position from root file.
//create lightguide probability from positions.
//export probability to new root file. 
 	
int main()
{	
	const double pi = 3.1415926535897;  //pi
	Double_t pmtprob[8];
	
	

//open mpm's analyzed root file, then load a tree
   TFile *myFile2 = TFile::Open("/home/cmswank/G4Work/output/thinfoil_Xe135_3-2+/analyzed_1.root");
   TTree *anaTree = (TTree*)myFile2->Get("anaTree");
//create new file for the map to go into 
   TFile myFile("pmtprob_1.root","recreate");
   TTree *pmtTree=new TTree("pmtTree","pmt map");

	//add 	 Branch
   TBranch *PMTmap = pmtTree->Branch("PMTmap",&pmtprob,"PMTmap[8]/D");
	//define position array
   Double_t hitpos[6];
    ////get number of entries. 
   Int_t linum=(Int_t)anaTree->GetEntries();
	//set position branch addres to position array   
	anaTree->SetBranchAddress("MWPCPos",&hitpos);



	
	string lgps;
  	double xpos[linum];
	double ypos[linum];
	double tlgp[linum];  	
    	int ii = 0;
         int west = 0;
    	while (ii<linum)
    	{   
	    anaTree->GetEntry(ii);
	    //west side or east side?
	    if (hitpos[3]==0){  
	    west = 1; //west side
     	    xpos[ii] = 10*hitpos[4];  //change units from cm to mm (10*hitpos). 
  	    ypos[ii] = 10*hitpos[5];}	
   	    else
            {
	    west=0;//east side
	    xpos[ii] = 10*hitpos[1];
  	    ypos[ii] = 10*hitpos[2];	
             }
	for (int i=0; i<8;++i) pmtprob[i]=0.000;         //clear pmtprob (stupid way)

///eventually I will need to use coupling coefficients/offsets.
	for (int i=0; i<4; ++i) pmtprob[4*west+i]=PMTprob(xpos[ii],ypos[ii],0,0,1,1,1,i+1); //
            //lgp[ii] = lightguideprob(xpos[ii],ypos[ii],0); ///LG Probability function
	    tlgp[ii]=PMTprob(xpos[ii],ypos[ii],0,0,1,1,1,1)+PMTprob(xpos[ii],ypos[ii],0,0,1,1,1,2)+PMTprob(xpos[ii],ypos[ii],0,0,1,1,1,3)+PMTprob(xpos[ii],ypos[ii],0,0,1,1,1,4); ///PMT Total Probablility check!
		
		if (tlgp[ii]>1.05)
		{      //all errors tend to be less than 1% e.g. prob=1.00X where X is < 5.
			// still its pretty big, thats what we get for using atan2?...
		  cout<<"Warning, Probabililty>1, something isn't right here.\n";
	          				
		}
		pmtTree->Fill(); //fill the branch  (How does it know what entry I'm on? Magic!?!?)
		++ii;	 	
  	   }   
 	pmtTree->Write(); //write the file. 
 	                 



   return 0;

}
